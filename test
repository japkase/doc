import java.nio.file.Files

def boundary = 'MIMEBoundary' + UUID.randomUUID().toString().replace('-', '')
vars.put('BOUNDARY', boundary)

def cid = 'doc1-' + System.currentTimeMillis() + '@jmeter'
vars.put('CID', cid)

// SOAP zarf şablonunuzda ${CID} placeholder’ı olsun (xop:Include içinde)
def soapTemplatePath = '/ABSOLUTE/PATH/soap_envelope.xml'
def envelope = new File(soapTemplatePath).getText('UTF-8').replace('${CID}', cid)

// Göndereceğiniz dosya
def filePath = '/ABSOLUTE/PATH/document.pdf'
byte[] fileBytes = new File(filePath).bytes

def CRLF = '\r\n'
ByteArrayOutputStream baos = new ByteArrayOutputStream()
def writer = new OutputStreamWriter(baos, 'UTF-8')

// Root SOAP part
writer << '--' + boundary + CRLF
writer << 'Content-Type: application/xop+xml; charset=UTF-8; type="text/xml"' + CRLF
writer << 'Content-Transfer-Encoding: 8bit' + CRLF
writer << 'Content-ID: <rootpart@jmeter>' + CRLF + CRLF
writer << envelope + CRLF
writer.flush()

// Attachment part
writer << '--' + boundary + CRLF
writer << 'Content-Type: application/pdf' + CRLF
writer << 'Content-Transfer-Encoding: binary' + CRLF
writer << 'Content-ID: <' + cid + '>' + CRLF + CRLF
writer.flush()
baos.write(fileBytes)
writer << CRLF
writer << '--' + boundary + '--' + CRLF
writer.flush()

byte[] payload = baos.toByteArray()
def tmp = File.createTempFile('mtom-', '.mime')
Files.write(tmp.toPath(), payload)
vars.put('RAW_FILE', tmp.absolutePath)


def base64 = new File('/ABSOLUTE/PATH/document.pdf').bytes.encodeBase64().toString()
vars.put('FILE_BASE64', base64)

def base64 = java.util.Base64.getEncoder().encodeToString(new File('/ABSOLUTE/PATH/document.pdf').bytes)
vars.put('FILE_BASE64', base64)


find . -type f -path '*/build/test-results/*/*.xml' -print0 \
 | xargs -0 grep -ho '<testcase ' | wc -l


rg -n -U -P '@(Test|ParameterizedTest|RepeatedTest|TestFactory|TestTemplate)(?:.|\n){0,5}\b([A-Za-z_][A-Za-z0-9_]*)\s*\(' src/test/java --no-filename --replace '$2' | sort | uniq -c | awk '$1>1' | sort -nr


rg -n -U -P '@(Test|ParameterizedTest|RepeatedTest|TestFactory|TestTemplate)(?:.|\n){0,5}\b([A-Za-z_][A-Za-z0-9_]*)\s*\(' src/test/java \
  --no-filename --replace '$2' \
| sort | uniq -c | awk '$1>1' | sort -nr


Get-ChildItem .\src\test\java -Recurse -Include *.java | % { $s = Get-Content $_.FullName -Raw; [regex]::Matches($s, '@(Test|ParameterizedTest|RepeatedTest|TestFactory|TestTemplate)[\s\S]{0,400}?(?:public|protected|private)?\s*(?:static\s+)?[\w\<\>\[\]\?,\.\s]+\s+([A-Za-z_]\w*)\s*\(') | % { $_.Groups[2].Value } } | Group-Object | ? { $_.Count -gt 1 } | Sort-Object Count -Descending | ft Count,Name -Auto





tasks.register('duplicateTestNames') {
  group = 'verification'
  description = 'Find duplicate JUnit test method names in src/test/java'
  doLast {
    def roots = [file('src/test/java')] // Kotlin testler varsa: add file('src/test/kotlin')
    def pattern = java.util.regex.Pattern.compile(
      '@(Test|ParameterizedTest|RepeatedTest|TestFactory|TestTemplate)(?s).{0,400}?'
      + '(?:public|protected|private)?\\s*(?:static\\s+)?[\\w<>\\[\\]\\?,\\.\\s]+\\s+([A-Za-z_]\\w*)\\s*\\('
    )
    def counts = new LinkedHashMap<String,Integer>().withDefault{0}
    def occ = new LinkedHashMap<String, java.util.List<String>>().withDefault{[]}
    roots.findAll{ it.exists() }.each { dir ->
      dir.eachFileRecurse { f ->
        if (f.name.endsWith('.java')) { // .kt de eklemek isterseniz: || f.name.endsWith('.kt')
          def s = f.getText('UTF-8')
          def m = pattern.matcher(s)
          while (m.find()) {
            def name = m.group(2)
            counts[name] = counts[name] + 1
            def line = s.substring(0, m.start()).split('\\R').length
            occ[name] = (occ[name] + ["${f.path}:${line}"]) as java.util.List<String>
          }
        }
      }
    }
    def dups = counts.findAll { k,v -> v > 1 }.sort { -it.value }
    if (dups.isEmpty()) {
      println 'No duplicate test method names found.'
    } else {
      println 'Duplicates (count\tname):'
      dups.each { k,v -> println "${v}\t${k}" }
      println '\nLocations:'
      dups.keySet().each { name -> occ[name].each { println it } }
    }
  }
}










stage('Import to Jira') {
      agent {
               label 'linux'
       }
       when {
               beforeAgent true
               beforeInput true
               expression {
                 ['dev','stable','sstest','preprod'].contains(params.TESTENV) &&
                 ['dev','stable'].contains(params.TESTDOMAIN) &&
                 ['all','regression'].contains(params.TAG) &&
                 !isLibrary &&
                 params.Xray
               }
       }
       tools {
               jdk 'java-17'
       }
       environment {
               JIRA_BASE_URL = 'https://jira.example.com'     // Jira Server/DC URL'iniz
               JIRA_PAT_CRED = 'jira-pat-id'                  // Jenkins Secret Text credential ID (PAT)
       }
       steps {
               script {
                  // 1) Allure raporunu üret ve zip’le
                  sh "allure generate ${PROJECT_NAME}/build/allure-results -o allure-report --clean || true"
                  sh "zip -r -q allure-report.zip allure-report || true"

                  // 2) Jenkins’te Allure raporu URL’i
                  def allureReportUrl = "${env.BUILD_URL}allure/"

                  // 3) Xray’e JUnit import + TE açıklamasına Allure URL
                  exws (extWorkspace) {
                        step([$class: 'XrayImportBuilder',
                               endpointName: '/junit',
                               importFilePath: "${PROJECT_NAME}/build/test-results/**/*.xml",
                               importInParallel: 'false',
                               importToSameExecution: 'true',
                               projectKey: 'TM',
                               serverInstance: 'SERVER-asdsadas-232dsada-sdsdsad-dsd',
                               // Eklenti sürümüne göre aşağıdaki iki seçenekten biri çalışır:
                               // testExecInfoJson veya testExecInfo
                               testExecInfoJson: """{
                                 "fields": {
                                   "summary": "Test Execution - ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                                   "description": "Allure Report: ${allureReportUrl}"
                                 }
                               }""",
                               testExecKeyOutput: 'XRAY_TE_KEY'
                         ])
                  }

                  if (!env.XRAY_TE_KEY) {
                     error "Xray Test Execution anahtarı alınamadı. 'testExecKeyOutput' desteğini kontrol edin."
                  }

                  // 4) Allure zip’i TE issue’una PAT ile attachment olarak yükle
                  withCredentials([string(credentialsId: env.JIRA_PAT_CRED, variable: 'JIRA_PAT')]) {
                      sh "curl -sS -H 'X-Atlassian-Token: no-check' -H \"Authorization: Bearer ${JIRA_PAT}\" -F file=@allure-report.zip ${JIRA_BASE_URL}/rest/api/2/issue/${env.XRAY_TE_KEY}/attachments | cat"
                  }
               }
         }
         post {
           always {
             // Jenkins UI'de Allure raporunu yayınla (BUILD_URL/allure/)
             allure(results: [[path: "${PROJECT_NAME}/build/allure-results"]])
           }
         }
}
